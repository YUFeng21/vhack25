import Agent from 'agentkeepalive';
import { z } from 'zod';
import axios from 'axios';
import axiosRetry from 'axios-retry';

function createHttpAgent(payload = { maxFreeSockets: 10, freeSocketTimeout: 20000 }) {
    return new Agent(payload);
}
function createHttpsAgent(payload = { maxFreeSockets: 10, freeSocketTimeout: 20000 }) {
    return new Agent.HttpsAgent(payload);
}
// https://github.com/colinhacks/zod/issues/2938
// Custom passthrough function for zod schema
const passthrough = (schema) => {
    return schema.and(z.record(z.string(), z.any()));
};
const isRunningInBrowser = () => {
    return (
    // @ts-ignore
    typeof window !== "undefined" &&
        // @ts-ignore
        typeof window.document !== "undefined" &&
        // @ts-ignore
        typeof navigator !== "undefined");
};
// Define a generic function to create a pagination schema
function createPaginationSchema(itemSchema) {
    return passthrough(z.object({
        items: z.array(itemSchema).describe("List of items paginated items.").default([]),
        offset: z.number().describe("Number of skipped items.").default(0),
        limit: z.number().describe("Number of items per page.").default(100),
        total: z.number().describe("Total number of items.").default(0)
    }));
}

const getOSInfoBrwoser = () => {
    const userAgent = window.navigator.userAgent;
    const platform = window.navigator.platform;
    const architecture = window.navigator.userAgent.includes("WOW64") || window.navigator.userAgent.includes("Win64") ? "x64" : "x86";
    let browser = "Unknown";
    if (userAgent.includes("Firefox")) {
        browser = "Firefox";
    }
    else if (userAgent.includes("Chrome")) {
        browser = "Chrome";
    }
    else if (userAgent.includes("Safari")) {
        browser = "Safari";
    }
    else if (userAgent.includes("Edge")) {
        browser = "Edge";
    }
    else if (userAgent.includes("Opera") || userAgent.includes("OPR")) {
        browser = "Opera";
    }
    let os = "Unknown OS";
    if (platform?.startsWith("Win")) {
        os = "Windows";
    }
    else if (platform?.startsWith("Mac")) {
        os = "macOS";
    }
    else if (platform?.startsWith("Linux")) {
        os = "Linux";
    }
    else if (/Android/.test(userAgent)) {
        os = "Android";
    }
    else if (/iPhone|iPad|iPod/.test(userAgent)) {
        os = "iOS";
    }
    return `${browser}-${os}; ${architecture}`;
};

const getFileName = async (filePath) => {
    if (typeof window === "undefined") {
        const path = await import('path');
        return path?.basename(filePath);
    }
    return "";
};
const readFile = async (filePath) => {
    if (typeof window === "undefined") {
        const { promises: fs } = await import('fs');
        return await fs?.readFile(filePath);
    }
    return "";
};
const getMimeType = async (filePath) => {
    if (typeof window === "undefined") {
        const mime = await import('mime-types');
        return mime?.lookup(filePath) || "application/octet-stream";
    }
    return "";
};
const getOSInfoNode = async () => {
    if (typeof window === "undefined") {
        const os = await import('os');
        const platform = os?.platform() || "";
        const arch = os?.arch();
        let osName = "Unknown OS";
        switch (platform) {
            case "win32":
                osName = "Windows";
                break;
            case "darwin":
                osName = "macOS";
                break;
            case "linux":
                osName = "Linux";
                break;
            default:
                osName = platform;
        }
        return `${osName} ${os?.release()}; ${arch}`;
    }
    return "";
};

class Base {
    maxRetries;
    httpClient;
    timeout;
    sdkVersion = "0.3";
    /**
     * Creates an instance of APIClient.
     * @param {string} baseURL Base URL for the API requests. Default url is - https://api.jamaibase.com
     * @param {string} token PAT.
     * @param {string} projectId Project ID.
     * @param {number=} [maxRetries=0] Maximum number of retries for failed requests. Defaults value is 0.
     * @param {AxiosInstance} [httpClient] Axios instance for making HTTP requests. If not provided, a default instance will be created.
     * @param {number} [timeout] Timeout (ms) for the requests. Default value is none.
     */
    constructor({ baseURL, token, projectId, maxRetries = 0, httpClient, timeout, dangerouslyAllowBrowser = false }) {
        this.maxRetries = maxRetries;
        this.httpClient = httpClient || axios.create({});
        this.timeout = timeout;
        if (!dangerouslyAllowBrowser && isRunningInBrowser()) {
            throw new Error("It looks like you're running in a browser-like environment.\n\nThis is disabled by default, as it risks exposing your secret API credentials to attackers.\nIf you understand the risks and have appropriate mitigations in place,\nyou can set the `dangerouslyAllowBrowser` option to `true`, e.g.,\n\nnew JamAI({ token, dangerouslyAllowBrowser: true });");
        }
        // Setting up the interceptor
        this.httpClient.interceptors.request.use(async (config) => {
            const userAgent = await this.generateUserAgent();
            config.headers["User-Agent"] = userAgent;
            return config;
        }, (error) => {
            // Handle the request error here
            return Promise.reject(error);
        });
        // add baseurl to axios instance
        this.httpClient.defaults.baseURL = baseURL || "https://api.jamaibase.com";
        // add apikey and project id to header if provided
        if (token) {
            this.setApiKey(token);
        }
        if (projectId) {
            this.setProjId(projectId);
        }
        // add timeout to client
        if (this.timeout) {
            this.httpClient.defaults.timeout = this.timeout;
        }
        // add retry on failed requests
        if (maxRetries > 0) {
            axiosRetry(this.httpClient, {
                retries: this.maxRetries,
                retryDelay: (retryCount) => {
                    console.log("Retry attempt: ", retryCount);
                    return retryCount * 1000;
                },
                retryCondition: (_error) => {
                    return true;
                }
            });
        }
        // add agent pool
        if (!isRunningInBrowser()) {
            this.httpClient.defaults.httpAgent = createHttpAgent();
            this.httpClient.defaults.httpsAgent = createHttpsAgent();
        }
        // (TODO): add agent for browser (default browser)
    }
    /**
     * Options for configuring the HTTP agent.
     * @property {Boolean} [keepAlive=true] - Keep sockets around in a pool to be used by other requests in the future. Default is true.
     * @property {Number} [keepAliveMsecs=1000] - Initial delay for TCP Keep-Alive packets when keepAlive is enabled. Defaults to 1000 milliseconds. Only relevant if keepAlive is true.
     * @property {Number} [freeSocketTimeout=20000] - Timeout for free sockets after inactivity, in milliseconds. Default is 20000 milliseconds. Only relevant if keepAlive is true.
     * @property {Number} [timeout] - Timeout for working sockets after inactivity, in milliseconds. Default is calculated as freeSocketTimeout * 2 if greater than or equal to 8000 milliseconds, otherwise the default is 8000 milliseconds.
     * @property {Number} [maxSockets=Infinity] - Maximum number of sockets to allow per host. Default is Infinity.
     * @property {Number} [maxFreeSockets=10] - Maximum number of free sockets per host to keep open. Only relevant if keepAlive is true. Default is 10.
     * @property {Number} [socketActiveTTL=null] - Sets the time to live for active sockets, even if in use. If not set, sockets are released only when free. Default is null.
     */
    setHttpagentConfig(payload) {
        this.httpClient.defaults.httpAgent = createHttpAgent(payload);
    }
    /**
     * Options for configuring the HTTP agent.
     * @property {Boolean} [keepAlive=true] - Keep sockets around in a pool to be used by other requests in the future. Default is true.
     * @property {Number} [keepAliveMsecs=1000] - Initial delay for TCP Keep-Alive packets when keepAlive is enabled. Defaults to 1000 milliseconds. Only relevant if keepAlive is true.
     * @property {Number} [freeSocketTimeout=20000] - Timeout for free sockets after inactivity, in milliseconds. Default is 20000 milliseconds. Only relevant if keepAlive is true.
     * @property {Number} [timeout] - Timeout for working sockets after inactivity, in milliseconds. Default is calculated as freeSocketTimeout * 2 if greater than or equal to 8000 milliseconds, otherwise the default is 8000 milliseconds.
     * @property {Number} [maxSockets=Infinity] - Maximum number of sockets to allow per host. Default is Infinity.
     * @property {Number} [maxFreeSockets=10] - Maximum number of free sockets per host to keep open. Only relevant if keepAlive is true. Default is 10.
     * @property {Number} [socketActiveTTL=null] - Sets the time to live for active sockets, even if in use. If not set, sockets are released only when free. Default is null.
     */
    setHttpsagentConfig(payload) {
        this.httpClient.defaults.httpsAgent = createHttpsAgent(payload);
    }
    async health() {
        let getURL = `/api/health`;
        return this.httpClient.get(getURL);
    }
    setApiKey(token) {
        this.httpClient.defaults.headers.common["Authorization"] = `Bearer ${token}`;
    }
    setProjId(projectId) {
        this.httpClient.defaults.headers.common["X-PROJECT-ID"] = projectId;
    }
    setAuthHeader(header) {
        this.httpClient.defaults.headers.common["Authorization"] = header;
    }
    // Helper method to log warnings if present
    logWarning(response) {
        const warning = response.headers["warning"];
        if (warning) {
            console.warn(warning);
        }
    }
    // Helper method to handle response validation
    handleResponse(response, schema) {
        this.logWarning(response);
        if (response.status !== 200) {
            throw new Error(`Received Error Status: ${response.status}`);
        }
        if (schema) {
            const parsedData = schema.parse(response.data);
            return parsedData;
        }
        else {
            return response.data;
        }
    }
    // Method to get language and version (TypeScript or JavaScript)
    getLanguageAndVersion() {
        try {
            // Check if TypeScript is being used
            const tsVersion = require("typescript").version;
            return { language: "TypeScript", version: tsVersion };
        }
        catch (error) {
            // Fallback to JavaScript if TypeScript is not detected
            return { language: "JavaScript", version: process.version };
        }
    }
    async generateUserAgent() {
        const sdkVersion = this.sdkVersion;
        const { language, version } = this.getLanguageAndVersion();
        let osInfo = "";
        if (isRunningInBrowser()) {
            osInfo = getOSInfoBrwoser();
        }
        else {
            osInfo = await getOSInfoNode();
        }
        return `SDK/${sdkVersion} (${language}/${version}; ${osInfo})`;
    }
}

const UploadFileRequestSchema = z.object({
    file: z
        .any()
        .optional(),
    file_path: z.string().optional()
});
const UploadFileResponseSchema = z.object({
    object: z.literal("file.upload"),
    uri: z.string()
});
const GetUrlRequestSchema = z.object({
    uris: z.array(z.string())
});
const GetUrlResponseSchema = z.object({
    object: z.literal("file.urls"),
    urls: z.array(z.string())
});

async function createFormData$1() {
    if (!isRunningInBrowser()) {
        // Node environment
        // (import from `formdata-node`)
        const { FormData } = await import('formdata-node');
        return new FormData();
    }
    else {
        // Browser environment
        return new FormData();
    }
}
class Files extends Base {
    async uploadFile(params) {
        const apiURL = `/api/v1/files/upload`;
        const parsedParams = UploadFileRequestSchema.parse(params);
        // Create FormData to send as multipart/form-data
        const formData = await createFormData$1();
        if (parsedParams.file) {
            formData.append("file", parsedParams.file, parsedParams.file.name);
        }
        else if (parsedParams.file_path) {
            if (!isRunningInBrowser()) {
                const mimeType = await getMimeType(parsedParams.file_path);
                const fileName = await getFileName(parsedParams.file_path);
                const data = await readFile(parsedParams.file_path);
                // const file = new Blob([data], { type: mimeType });
                const { File } = await import('formdata-node');
                const file = new File([data], fileName, { type: mimeType });
                // @ts-ignore
                formData.append("file", file, fileName);
            }
            else {
                throw new Error("Pass File instead of file path if you are using this function in client.");
            }
        }
        else {
            throw new Error("Either File or file_path is required.");
        }
        const response = await this.httpClient.post(apiURL, formData, {
            headers: {
                "Content-Type": "multipart/form-data"
            }
        });
        return this.handleResponse(response, UploadFileResponseSchema);
    }
    async getRawUrls(params) {
        const parsedParams = GetUrlRequestSchema.parse(params);
        const apiURL = `/api/v1/files/url/raw`;
        const response = await this.httpClient.post(apiURL, {
            uris: parsedParams.uris
        });
        return this.handleResponse(response, GetUrlResponseSchema);
    }
    async getThumbUrls(params) {
        const parsedParams = GetUrlRequestSchema.parse(params);
        const apiURL = `/api/v1/files/url/thumb`;
        const response = await this.httpClient.post(apiURL, {
            uris: parsedParams.uris
        });
        return this.handleResponse(response, GetUrlResponseSchema);
    }
}

/**
 * Represents who said a chat message.
 */
const ChatRoleSchema = z.enum(["system", "user", "assistant", "function"]);
const ChatEntrySchema = z.object({
    role: ChatRoleSchema,
    content: z.union([z.string(), z.array(z.record(z.union([z.string(), z.record(z.string())])))]),
    name: z.string().optional().nullable()
});
const RAGParamsSchema = z.object({
    search_query: z.string().optional(),
    k: z.number().optional(),
    fetch_k: z.number().optional(),
    document_ids: z.array(z.string()).optional(),
    rank_profile: z.enum(["bm25", "semantic", "hybrid", "hybrid_log"]).optional(),
    rerank: z.boolean().optional(),
    concat_reranker_input: z.boolean().optional()
});
const FunctionSpecSchema = z.object({
    name: z.string(),
    description: z.string().optional(),
    parameters: z.record(z.string(), z.any())
});
z.object({
    type: z.string().optional(),
    function: FunctionSpecSchema
});
z.object({
    name: z.string()
});
const ChatCompletionUsageSchema = z.object({
    prompt_tokens: z.number().nullable().optional().default(0),
    completion_tokens: z.number().nullable().optional().default(0),
    total_tokens: z.number().nullable().optional().default(0)
});
/**
 * Represents a message in the chat context.
 */
// export type ChatEntry = {
//   role: ChatRole;
//   content: string;
//   name?: string | null;
// };
const ChatRequestSchema = z.object({
    id: z.string().default(""),
    model: z.string().default(""),
    messages: z.array(ChatEntrySchema),
    rag_params: RAGParamsSchema.nullable().default(null),
    temperature: z.number().min(0.001).max(2.0).default(0.2),
    top_p: z.number().min(0.001).max(1.0).default(0.6),
    n: z.number().default(1),
    stream: z.boolean().default(true),
    stop: z.array(z.string()).nullable().default(null),
    max_tokens: z.number().int().min(1).default(2048),
    presence_penalty: z.number().default(0.0),
    frequency_penalty: z.number().default(0.0),
    logit_bias: z.record(z.string(), z.any()).default({}),
    user: z.string().default("")
});
const ChatCompletionChoiceSchema = z.object({
    message: ChatEntrySchema,
    index: z.number(),
    finish_reason: z.string().nullable()
});
const ChatCompletionChoiceDeltaSchema = z.object({
    message: ChatEntrySchema,
    index: z.number(),
    finish_reason: z.string().nullable(),
    delta: ChatEntrySchema.nullable()
});
const ChunkSchema = z.object({
    text: z.string(),
    title: z.string(),
    page: z.number(),
    file_name: z.string(),
    file_path: z.string(),
    document_id: z.string(),
    chunk_id: z.string(),
    metadata: z.record(z.string(), z.any())
});
const ReferencesSchema = z.object({
    object: z.enum(["chat.references"]),
    chunks: z.array(ChunkSchema),
    search_query: z.string().describe("Query used to retrieve items from the KB database."),
    finish_reason: z.enum(["stop", "context_overflow"]).nullable()
});
const ChatCompletionChunkSchema = z.object({
    id: z.string(),
    object: z.enum(["chat.completion"]),
    created: z.number(),
    model: z.string(),
    usage: ChatCompletionUsageSchema.nullable().optional(),
    // choices: z.array(ChatCompletionChoiceSchema),
    choices: z.union([z.array(ChatCompletionChoiceSchema), z.array(ChatCompletionChoiceDeltaSchema)]),
    references: ReferencesSchema.nullable().optional()
});
const StreamChatCompletionChunkSchema = z.object({
    id: z.string(),
    object: z.enum(["chat.completion.chunk"]),
    created: z.number(),
    model: z.string(),
    usage: ChatCompletionUsageSchema.nullable().optional(),
    choices: z.array(ChatCompletionChoiceDeltaSchema),
    // choices: z.union([z.array(ChatCompletionChoiceSchema), z.array(ChatCompletionChoiceDeltaSchema)]),
    references: ReferencesSchema.nullable().optional()
});

const GenTableOrderBy = Object.freeze({
    ID: "id", // Sort by `id` column
    UPDATED_AT: "updated_at" // Sort by `updated_at` column
});
const QueryRequestParams = z.object({
    offset: z.number().describe("Number of skipped items.").default(0),
    limit: z.number().describe("Number of items per page.").default(100)
});
const TableTypesSchema = z.enum(["action", "knowledge", "chat"]);
const IdSchema = z.string().regex(/^[A-Za-z0-9]([A-Za-z0-9 _-]{0,98}[A-Za-z0-9])?$/, "Invalid Id");
const TableIdSchema = z.string().regex(/^[A-Za-z0-9]([A-Za-z0-9._-]{0,98}[A-Za-z0-9])?$/, "Invalid Table Id");
const DtypeCreateEnumSchema = z.enum(["int", "float", "str", "bool", "image", "audio"]);
const DtypeEnumSchema = z.enum(["int", "int8", "float", "float64", "float32", "float16", "bool", "str", "date-time", "image", "bytes", "audio"]);
const EmbedGenConfigSchema = z.object({
    object: z.literal("gen_config.embed").default("gen_config.embed"),
    embedding_model: z.string(),
    source_column: z.string()
});
const LLMGenConfigSchema = z.object({
    object: z.literal("gen_config.llm").default("gen_config.llm"),
    model: z.string().default(""),
    prompt: z.string().default(""),
    system_prompt: z.string().default(""),
    multi_turn: z.boolean().default(false),
    rag_params: RAGParamsSchema.nullable().default(null),
    temperature: z.number().min(0.001).max(2.0).default(0.2),
    top_p: z.number().min(0.001).max(1.0).default(0.6),
    stop: z.array(z.string()).nullable().default(null),
    max_tokens: z.number().int().min(1).default(2048),
    presence_penalty: z.number().default(0.0),
    frequency_penalty: z.number().default(0.0),
    logit_bias: z.record(z.string(), z.any()).default({})
});
const CodeGenConfigSchema = z.object({
    object: z.literal("gen_config.code").default("gen_config.code"),
    source_column: z.string()
});
const ColumnSchemaSchema = z.object({
    id: z.string(),
    dtype: DtypeEnumSchema.default("str"),
    vlen: z.number().int().gte(0).default(0),
    index: z.boolean().default(true),
    gen_config: z.union([LLMGenConfigSchema, EmbedGenConfigSchema, CodeGenConfigSchema, z.null()]).optional()
});
const ColumnSchemaCreateSchema = ColumnSchemaSchema.extend({
    id: IdSchema,
    dtype: DtypeCreateEnumSchema.default("str")
});
const TableSchemaCreateSchema = z.object({
    id: TableIdSchema,
    cols: z.array(ColumnSchemaCreateSchema)
});
let ListTableRequestSchema = QueryRequestParams.extend({
    parent_id: z.union([z.string(), z.null()]).optional(),
    table_type: TableTypesSchema,
    search_query: z.string().default(""),
    order_by: z.string().optional().default(GenTableOrderBy.UPDATED_AT),
    order_descending: z.boolean().optional().default(true),
    count_rows: z.boolean().optional().default(false)
});
const TableMetaResponseSchema = z.object({
    id: z.string(),
    cols: z.array(ColumnSchemaSchema),
    parent_id: z.union([z.string(), z.null()]),
    title: z.string(),
    lock_till: z.union([z.number(), z.null()]).optional(),
    updated_at: z.string(),
    indexed_at_fts: z.union([z.string(), z.null()]),
    indexed_at_vec: z.union([z.string(), z.null()]),
    indexed_at_sca: z.union([z.string(), z.null()]),
    num_rows: z.number().int()
});
z.object({
    table_type: TableTypesSchema,
    table_id: TableIdSchema
});
const ListTableRowsRequestSchema$1 = QueryRequestParams.extend({
    table_type: TableTypesSchema,
    table_id: TableIdSchema,
    columns: z.array(IdSchema).nullable().optional(),
    search_query: z.string().default(""),
    float_decimals: z.number().int().default(0),
    vec_decimals: z.number().int().default(0),
    order_descending: z.boolean().default(true)
});
const ListTableRowsResponseSchema$1 = z.record(z.string(), z.any());
const GetRowRequestSchema = z.object({
    table_type: TableTypesSchema,
    table_id: TableIdSchema,
    row_id: z.string(),
    columns: z.array(IdSchema).nullable().optional(),
    float_decimals: z.number().int().default(0),
    vec_decimals: z.number().int().default(0)
});
const GetRowResponseSchema = z.record(z.string(), z.any());
const PageListTableRowsResponseSchema = createPaginationSchema(ListTableRowsResponseSchema$1);
const PageListTableMetaResponseSchema = createPaginationSchema(TableMetaResponseSchema);
const OkResponseSchema = z.object({
    ok: z.boolean().default(true)
});
z.object({
    table_type: TableTypesSchema,
    table_id: TableIdSchema
});
z.object({
    table_type: TableTypesSchema,
    table_id_src: TableIdSchema,
    table_id_dst: TableIdSchema
});
const DuplicateTableRequestSchema = z.object({
    table_type: TableTypesSchema,
    table_id_src: TableIdSchema,
    table_id_dst: TableIdSchema.nullable().default(null),
    include_data: z.boolean().optional().default(true),
    create_as_child: z.boolean().optional().default(false)
});
z.object({
    table_type: TableTypesSchema,
    table_id_src: TableIdSchema,
    table_id_dst: TableIdSchema
});
z.object({
    table_type: TableTypesSchema,
    table_id: TableIdSchema,
    column_map: z.record(IdSchema, IdSchema)
});
z.object({
    table_type: TableTypesSchema,
    table_id: TableIdSchema,
    column_names: z.array(IdSchema)
});
const AddColumnRequestSchema = z.object({
    id: TableIdSchema,
    cols: z.array(ColumnSchemaCreateSchema)
});
const UpdateGenConfigRequestSchema = z.object({
    table_type: TableTypesSchema,
    table_id: TableIdSchema,
    column_map: z.record(z.string(), z.union([LLMGenConfigSchema, EmbedGenConfigSchema, CodeGenConfigSchema, z.null()]))
});
z.object({
    table_type: TableTypesSchema,
    table_id: TableIdSchema,
    row_id: z.string(),
    reindex: z.boolean().default(true)
});
z.object({
    table_type: TableTypesSchema,
    reindex: z.boolean().nullable().default(true),
    table_id: TableIdSchema,
    data: z.array(z.record(IdSchema, z.any())),
    concurrent: z.boolean().default(true)
    // stream: z.boolean()
});
z.object({
    table_type: TableTypesSchema,
    table_id: TableIdSchema,
    row_ids: z.array(z.string()),
    reindex: z.boolean().nullable().default(null),
    concurrent: z.boolean().default(true)
    // stream: z.boolean()
});
z.object({
    table_type: TableTypesSchema,
    table_id: TableIdSchema,
    row_id: z.string(),
    data: z.record(IdSchema, z.any()),
    reindex: z.boolean().nullable().default(null)
});
z.object({
    table_type: TableTypesSchema,
    table_id: TableIdSchema,
    where: z.string().optional(),
    reindex: z.boolean().default(true)
});
z.object({
    table_type: TableTypesSchema,
    table_id: TableIdSchema,
    query: z.string(),
    where: z.string().nullable().default(null).optional(),
    limit: z.number().gt(0).lte(1000).optional(),
    metric: z.string().optional(),
    nprobes: z.number().gt(0).lte(1000).optional(),
    refine_factor: z.number().gt(0).lte(1000).optional(),
    reranking_model: z.string().nullable().default(null).optional(),
    float_decimals: z.number().int().default(0),
    vec_decimals: z.number().int().default(0)
});
const HybridSearchResponseSchema = z.array(z.record(z.string(), z.any()));
z.object({
    id: z.string().regex(/^[a-zA-Z0-9][a-zA-Z0-9_ \-]{0,98}[a-zA-Z0-9]$/),
    cols: z.array(ColumnSchemaSchema)
});
z.object({
    file_path: z.string().optional(),
    file: z
        .any()
        .optional(),
    table_id: TableIdSchema,
    table_type: TableTypesSchema,
    delimiter: z.string().default(",").optional()
});
const ExportTableRequestSchema = z.object({
    table_type: TableTypesSchema,
    table_id: TableIdSchema,
    delimiter: z.string().default(","),
    columns: z.array(z.string()).nullable().optional()
});

const CreateActionTableRequestSchema = TableSchemaCreateSchema;
const AddActionColumnRequestSchema = TableSchemaCreateSchema;

const GetConversationThreadRequestSchema = z.object({
    table_id: IdSchema,
    column_id: IdSchema,
    row_id: z.string().default(""),
    table_type: TableTypesSchema,
    include: z.boolean().default(true)
});
const GetConversationThreadResponseSchema = z.object({
    object: z.enum(["chat.thread"]).describe("Type of API response object."),
    thread: z.array(ChatEntrySchema).describe("List of chat messages.").default([])
});
const GenTableChatCompletionChunksSchema = z.object({
    object: z.enum(["gen_table.completion.chunks"]),
    columns: z.record(z.string(), ChatCompletionChunkSchema),
    row_id: z.string()
});
const GenTableRowsChatCompletionChunksSchema = z.object({
    object: z.enum(["gen_table.completion.rows"]),
    rows: z.array(GenTableChatCompletionChunksSchema)
});
const GenTableStreamChatCompletionChunkSchema = ChatCompletionChunkSchema.extend({
    object: z.enum(["gen_table.completion.chunk"]),
    output_column_name: z.string(),
    row_id: z.string()
});
const GenTableStreamReferencesSchema = ReferencesSchema.extend({
    object: z.enum(["gen_table.references"]),
    output_column_name: z.string()
});
const CreateChatTableRequestSchema = TableSchemaCreateSchema;

const CreateKnowledgeTableRequestSchema = TableSchemaCreateSchema.extend({
    embedding_model: z.string()
});
z.object({
    file: z.any().optional(),
    file_path: z.string().optional(),
    table_id: IdSchema,
    chunk_size: z.number().gt(0).optional(),
    chunk_overlap: z.number().min(0).optional()
});

class ChunkError extends Error {
    type = "ChunkError";
    constructor(message) {
        super(message);
        this.name = this.constructor.name;
        this.message = message || "";
        Error.captureStackTrace(this, this.constructor); // Capture stack trace
    }
    toString() {
        return `[${this.type} -  ${this.message}`;
    }
}

// import { Blob, FormData } from "formdata-node";
async function createFormData() {
    if (!isRunningInBrowser()) {
        // Node environment
        // (import from `formdata-node`)
        const { FormData } = await import('formdata-node');
        return new FormData();
    }
    else {
        // Browser environment
        return new FormData();
    }
}
class GenTable extends Base {
    // Helper method to handle stream responses
    handleGenTableStreamResponse(response) {
        this.logWarning(response);
        if (response.status != 200) {
            throw new Error(`Received Error Status: ${response.status}`);
        }
        return new ReadableStream({
            async start(controller) {
                response.data.on("data", (data) => {
                    data = data.toString();
                    if (data.endsWith("\n\n")) {
                        const lines = data
                            .split("\n\n")
                            .filter((i) => i.trim())
                            .flatMap((line) => line.split("\n")); // Split by \n to handle collation
                        for (const line of lines) {
                            const chunk = line
                                .toString()
                                .replace(/^data: /, "")
                                .replace(/data: \[DONE\]\s+$/, "");
                            if (chunk.trim() === "[DONE]")
                                return;
                            try {
                                const parsedValue = JSON.parse(chunk);
                                if (parsedValue["object"] === "gen_table.completion.chunk") {
                                    controller.enqueue(GenTableStreamChatCompletionChunkSchema.parse(parsedValue));
                                }
                                else if (parsedValue["object"] === "gen_table.references") {
                                    controller.enqueue(GenTableStreamReferencesSchema.parse(parsedValue));
                                }
                                else {
                                    throw new ChunkError(`Unexpected SSE Chunk: ${parsedValue}`);
                                }
                            }
                            catch (err) {
                                if (err instanceof ChunkError) {
                                    controller.error(new ChunkError(err.message));
                                }
                                else {
                                    continue;
                                }
                            }
                        }
                    }
                    else {
                        const chunk = data
                            .toString()
                            .replace(/^data: /, "")
                            .replace(/data: \[DONE\]\s+$/, "");
                        if (chunk.trim() === "[DONE]")
                            return;
                        try {
                            const parsedValue = JSON.parse(chunk);
                            if (parsedValue["object"] === "gen_table.completion.chunk") {
                                controller.enqueue(GenTableStreamChatCompletionChunkSchema.parse(parsedValue));
                            }
                            else if (parsedValue["object"] === "gen_table.references") {
                                controller.enqueue(GenTableStreamReferencesSchema.parse(parsedValue));
                            }
                            else {
                                throw new ChunkError(`Unexpected SSE Chunk: ${parsedValue}`);
                            }
                        }
                        catch (err) {
                            if (err instanceof ChunkError) {
                                controller.error(new ChunkError(err.message));
                            }
                        }
                    }
                });
                response.data.on("error", (data) => {
                    controller.error("Unexpected Error.");
                });
                response.data.on("end", () => {
                    if (controller.desiredSize !== null) {
                        controller.close();
                    }
                });
            }
        });
    }
    async listTables(params) {
        const parsedParams = ListTableRequestSchema.parse(params);
        let getURL = `/api/v1/gen_tables/${params.table_type}`;
        delete parsedParams.table_type;
        const response = await this.httpClient.get(getURL, {
            params: {
                ...parsedParams,
                search_query: encodeURIComponent(parsedParams.search_query)
            }
        });
        return this.handleResponse(response, PageListTableMetaResponseSchema);
    }
    async getTable(params) {
        let getURL = `/api/v1/gen_tables/${params.table_type}/${params.table_id}`;
        const response = await this.httpClient.get(getURL);
        return this.handleResponse(response, TableMetaResponseSchema);
    }
    async listRows(params) {
        const parsedParams = ListTableRowsRequestSchema$1.parse(params);
        const response = await this.httpClient.get(`/api/v1/gen_tables/${parsedParams.table_type}/${parsedParams.table_id}/rows`, {
            params: {
                offset: parsedParams.offset,
                limit: parsedParams.limit,
                search_query: encodeURIComponent(parsedParams.search_query),
                columns: parsedParams.columns ? parsedParams.columns?.map(encodeURIComponent) : [],
                float_decimals: parsedParams.float_decimals,
                vec_decimals: parsedParams.vec_decimals,
                order_descending: parsedParams.order_descending
            },
            paramsSerializer: (params) => {
                return Object.entries(params)
                    .flatMap(([key, value]) => (Array.isArray(value) ? value.map((val) => `${key}=${val}`) : `${key}=${value}`))
                    .join("&");
            }
        });
        return this.handleResponse(response, PageListTableRowsResponseSchema);
    }
    async getRow(params) {
        const parsedParams = GetRowRequestSchema.parse(params);
        const response = await this.httpClient.get(`/api/v1/gen_tables/${params.table_type}/${params.table_id}/rows/${params.row_id}`, {
            params: {
                columns: parsedParams.columns ? parsedParams.columns?.map(encodeURIComponent) : [],
                float_decimals: parsedParams.float_decimals,
                vec_decimals: parsedParams.vec_decimals
            },
            paramsSerializer: (params) => {
                return Object.entries(params)
                    .flatMap(([key, value]) => (Array.isArray(value) ? value.map((val) => `${key}=${val}`) : `${key}=${value}`))
                    .join("&");
            }
        });
        return this.handleResponse(response, GetRowResponseSchema);
    }
    async getConversationThread(params) {
        const parsedParams = GetConversationThreadRequestSchema.parse(params);
        let getURL = `/api/v1/gen_tables/${parsedParams.table_type}/${parsedParams.table_id}/thread`;
        const response = await this.httpClient.get(getURL, {
            params: {
                column_id: parsedParams.column_id,
                row_id: parsedParams.row_id,
                include: parsedParams.include
            }
        });
        return this.handleResponse(response, GetConversationThreadResponseSchema);
    }
    /*
     *  Gen Table Create
     */
    async createActionTable(params) {
        const parsedParams = CreateActionTableRequestSchema.parse(params);
        const apiURL = "/api/v1/gen_tables/action";
        const response = await this.httpClient.post(apiURL, {
            ...parsedParams,
            stream: false
        }, {});
        return this.handleResponse(response, TableMetaResponseSchema);
    }
    async createChatTable(params) {
        const parsedParams = CreateChatTableRequestSchema.parse(params);
        const apiURL = "/api/v1/gen_tables/chat";
        const response = await this.httpClient.post(apiURL, parsedParams);
        return this.handleResponse(response, TableMetaResponseSchema);
    }
    async createKnowledgeTable(params) {
        const parsedParams = CreateKnowledgeTableRequestSchema.parse(params);
        const apiURL = "/api/v1/gen_tables/knowledge";
        const response = await this.httpClient.post(apiURL, parsedParams);
        return this.handleResponse(response, TableMetaResponseSchema);
    }
    /*
     *  Gen Table Delete
     */
    async deleteTable(params) {
        let deleteURL = `/api/v1/gen_tables/${params.table_type}/${params.table_id}`;
        const response = await this.httpClient.delete(deleteURL);
        return this.handleResponse(response, OkResponseSchema);
    }
    async deleteRow(params) {
        let deleteURL = `/api/v1/gen_tables/${params.table_type}/${params.table_id}/rows/${params.row_id}`;
        const response = await this.httpClient.delete(deleteURL, {
            params: {
                reindex: params?.reindex
            }
        });
        return this.handleResponse(response, OkResponseSchema);
    }
    /**
     * @param {string} [params.where] - Optional. SQL where clause. If not provided, will match all rows and thus deleting all table content.
     */
    async deleteRows(params) {
        const apiURL = `/api/v1/gen_tables/${params.table_type}/rows/delete`;
        const response = await this.httpClient.post(apiURL, {
            table_id: params.table_id,
            where: params.where // Optional. SQL where clause. If not provided, will match all rows and thus deleting all table content.
        });
        return this.handleResponse(response, OkResponseSchema);
    }
    /*
     * Gen Table Update
     */
    async renameTable(params) {
        let postURL = `/api/v1/gen_tables/${params.table_type}/rename/${params.table_id_src}/${params.table_id_dst}`;
        const response = await this.httpClient.post(postURL, {}, {});
        return this.handleResponse(response, TableMetaResponseSchema);
    }
    async duplicateTable(params) {
        if ("deploy" in params) {
            console.warn(`The "deploy" argument is deprecated, use "create_as_child" instead.`);
            params.create_as_child = params.deploy;
            delete params.deploy;
        }
        const parsedParams = DuplicateTableRequestSchema.parse(params);
        let postURL = `/api/v1/gen_tables/${params.table_type}/duplicate/${params.table_id_src}`;
        const response = await this.httpClient.post(postURL, {}, {
            params: {
                table_id_dst: parsedParams.table_id_dst,
                include_data: parsedParams.include_data,
                create_as_child: parsedParams.create_as_child
            }
        });
        return this.handleResponse(response, TableMetaResponseSchema);
    }
    async renameColumns(params) {
        let postURL = `/api/v1/gen_tables/${params.table_type}/columns/rename`;
        const response = await this.httpClient.post(postURL, {
            table_id: params.table_id,
            column_map: params.column_map
        }, {});
        return this.handleResponse(response, TableMetaResponseSchema);
    }
    async reorderColumns(params) {
        let postURL = `/api/v1/gen_tables/${params.table_type}/columns/reorder`;
        const response = await this.httpClient.post(postURL, {
            table_id: params.table_id,
            column_names: params.column_names
        }, {});
        return this.handleResponse(response, TableMetaResponseSchema);
    }
    async dropColumns(params) {
        let postURL = `/api/v1/gen_tables/${params.table_type}/columns/drop`;
        const response = await this.httpClient.post(postURL, {
            table_id: params.table_id,
            column_names: params.column_names
        }, {});
        return this.handleResponse(response, TableMetaResponseSchema);
    }
    async addActionColumns(params) {
        const parsedParams = AddActionColumnRequestSchema.parse(params);
        let postURL = `/api/v1/gen_tables/action/columns/add`;
        const response = await this.httpClient.post(postURL, parsedParams);
        return this.handleResponse(response, TableMetaResponseSchema);
    }
    async addKnowledgeColumns(params) {
        const parsedParams = AddColumnRequestSchema.parse(params);
        let postURL = `/api/v1/gen_tables/knowledge/columns/add`;
        const response = await this.httpClient.post(postURL, parsedParams);
        return this.handleResponse(response, TableMetaResponseSchema);
    }
    async addChatColumns(params) {
        const parsedParams = AddColumnRequestSchema.parse(params);
        let postURL = `/api/v1/gen_tables/chat/columns/add`;
        const response = await this.httpClient.post(postURL, parsedParams);
        return this.handleResponse(response, TableMetaResponseSchema);
    }
    async updateGenConfig(params) {
        const parsedParams = UpdateGenConfigRequestSchema.parse(params);
        let postURL = `/api/v1/gen_tables/${params.table_type}/gen_config/update`;
        const response = await this.httpClient.post(postURL, {
            table_id: parsedParams.table_id,
            column_map: parsedParams.column_map
        }, {});
        return this.handleResponse(response, TableMetaResponseSchema);
    }
    async addRowStream(params) {
        const apiURL = `/api/v1/gen_tables/${params.table_type}/rows/add`;
        const response = await this.httpClient.post(apiURL, {
            table_id: params.table_id,
            data: params.data,
            stream: true,
            reindex: params.reindex,
            concurrent: params.concurrent
        }, {
            responseType: "stream"
        });
        return this.handleGenTableStreamResponse(response);
    }
    async addRow(params) {
        const url = `/api/v1/gen_tables/${params.table_type}/rows/add`;
        const response = await this.httpClient.post(url, {
            table_id: params.table_id,
            stream: false,
            data: params.data,
            reindex: params.reindex,
            concurrent: params.concurrent
        }, {});
        return this.handleResponse(response, GenTableRowsChatCompletionChunksSchema);
    }
    async regenRowStream(params) {
        const apiURL = `/api/v1/gen_tables/${params.table_type}/rows/regen`;
        const response = await this.httpClient.post(apiURL, {
            table_id: params.table_id,
            row_ids: params.row_ids,
            stream: true,
            reindex: params.reindex,
            concurrent: params.concurrent
        }, {
            responseType: "stream"
        });
        return this.handleGenTableStreamResponse(response);
    }
    async regenRow(params) {
        const apiURL = `/api/v1/gen_tables/${params.table_type}/rows/regen`;
        const response = await this.httpClient.post(apiURL, {
            table_id: params.table_id,
            row_ids: params.row_ids,
            stream: false,
            reindex: params.reindex,
            concurrent: params.concurrent
        }, {});
        return this.handleResponse(response, GenTableRowsChatCompletionChunksSchema);
    }
    async updateRow(params) {
        const apiURL = `/api/v1/gen_tables/${params.table_type}/rows/update`;
        const response = await this.httpClient.post(apiURL, {
            table_id: params.table_id,
            row_id: params.row_id,
            data: params.data,
            reindex: params.reindex
        });
        return this.handleResponse(response, OkResponseSchema);
    }
    async hybridSearch(params) {
        const apiURL = `/api/v1/gen_tables/${params.table_type}/hybrid_search`;
        const { table_type, ...requestBody } = params;
        const response = await this.httpClient.post(apiURL, requestBody);
        return this.handleResponse(response, HybridSearchResponseSchema);
    }
    /**
     * @deprecated This method will be removed in future versions.
     * Use the embedFile method instead.
     */
    // Function to upload a file
    async uploadFile(params) {
        const apiURL = `/api/v1/gen_tables/knowledge/upload_file`;
        // Create FormData to send as multipart/form-data
        const formData = await createFormData();
        if (params.file) {
            formData.append("file", params.file, params.file.name);
        }
        else if (params.file_path) {
            if (!isRunningInBrowser()) {
                const mimeType = await getMimeType(params.file_path);
                const fileName = await getFileName(params.file_path);
                const data = await readFile(params.file_path);
                const { File } = await import('formdata-node');
                const file = new File([data], fileName, { type: mimeType });
                // @ts-ignore
                formData.append("file", file, fileName);
            }
            else {
                throw new Error("Pass File instead of file path if you are using this function in client.");
            }
        }
        else {
            throw new Error("Either File or file_path is required.");
        }
        formData.append("table_id", params.table_id);
        // Optional: Add additional fields if required by the API
        if (params?.chunk_size) {
            formData.append("chunk_size", params.chunk_size.toString());
        }
        if (params?.chunk_overlap) {
            formData.append("chunk_overlap", params.chunk_overlap.toString());
        }
        const response = await this.httpClient.post(apiURL, formData, {
            headers: {
                "Content-Type": "multipart/form-data"
            }
        });
        return this.handleResponse(response, OkResponseSchema);
    }
    async embedFile(params) {
        const apiURL = `/api/v1/gen_tables/knowledge/embed_file`;
        // Create FormData to send as multipart/form-data
        const formData = await createFormData();
        if (params.file) {
            formData.append("file", params.file, params.file.name);
        }
        else if (params.file_path) {
            if (!isRunningInBrowser()) {
                const mimeType = await getMimeType(params.file_path);
                const fileName = await getFileName(params.file_path);
                const data = await readFile(params.file_path);
                const { File } = await import('formdata-node');
                const file = new File([data], fileName, { type: mimeType });
                // @ts-ignore
                formData.append("file", file, fileName);
            }
            else {
                throw new Error("Pass File instead of file path if you are using this method in client.");
            }
        }
        else {
            throw new Error("Either File or file_path is required.");
        }
        formData.append("table_id", params.table_id);
        // Optional: Add additional fields if required by the API
        if (params?.chunk_size) {
            formData.append("chunk_size", params.chunk_size.toString());
        }
        if (params?.chunk_overlap) {
            formData.append("chunk_overlap", params.chunk_overlap.toString());
        }
        const response = await this.httpClient.post(apiURL, formData, {
            headers: {
                "Content-Type": "multipart/form-data"
            }
        });
        return this.handleResponse(response, OkResponseSchema);
    }
    async importTableData(params) {
        const apiURL = `/api/v1/gen_tables/${params.table_type}/import_data`;
        const delimiter = params.delimiter ? params.delimiter : ",";
        const formData = await createFormData();
        if (params.file) {
            formData.append("file", params.file, params.file.name);
        }
        else if (params.file_path) {
            if (!isRunningInBrowser()) {
                const mimeType = await getMimeType(params.file_path);
                const fileName = await getFileName(params.file_path);
                const data = await readFile(params.file_path);
                // const file = new Blob([data], { type: mimeType });
                const { File } = await import('formdata-node');
                const file = new File([data], fileName, { type: mimeType });
                // @ts-ignore
                formData.append("file", file, fileName);
            }
            else {
                throw new Error("Pass File instead of file path if you are using this function in client.");
            }
        }
        else {
            throw new Error("Either File or file_path is required.");
        }
        formData.append("table_id", params.table_id);
        formData.append("delimiter", delimiter);
        formData.append("stream", JSON.stringify(false));
        const response = await this.httpClient.post(apiURL, formData, {
            headers: {
                "Content-Type": "multipart/form-data"
            }
        });
        return this.handleResponse(response, GenTableRowsChatCompletionChunksSchema);
    }
    async importTableDataStream(params) {
        const apiURL = `/api/v1/gen_tables/${params.table_type}/import_data`;
        // const fileName = params.file.name;
        const delimiter = params.delimiter ? params.delimiter : ",";
        const formData = await createFormData();
        if (params.file) {
            formData.append("file", params.file, params.file.name);
        }
        else if (params.file_path) {
            if (!isRunningInBrowser()) {
                const mimeType = await getMimeType(params.file_path);
                const fileName = await getFileName(params.file_path);
                const data = await readFile(params.file_path);
                const { File } = await import('formdata-node');
                const file = new File([data], fileName, { type: mimeType });
                // @ts-ignore
                formData.append("file", file, fileName);
            }
            else {
                throw new Error("Pass File instead of file path if you are using this function in client.");
            }
        }
        else {
            throw new Error("Either File or file_path is required.");
        }
        formData.append("table_id", params.table_id);
        formData.append("delimiter", delimiter);
        formData.append("stream", JSON.stringify(true));
        const response = await this.httpClient.post(apiURL, formData, {
            headers: {
                "Content-Type": "multipart/form-data"
            },
            responseType: "stream"
        });
        return this.handleGenTableStreamResponse(response);
    }
    async exportTableData(params) {
        const parsedParams = ExportTableRequestSchema.parse(params);
        const apiURL = `/api/v1/gen_tables/${parsedParams.table_type}/${encodeURIComponent(parsedParams.table_id)}/export_data`;
        try {
            const response = await this.httpClient.get(apiURL, {
                params: {
                    delimiter: encodeURIComponent(parsedParams.delimiter),
                    columns: parsedParams.columns ? parsedParams.columns?.map(encodeURIComponent) : []
                },
                paramsSerializer: (params) => {
                    return Object.entries(params)
                        .flatMap(([key, value]) => (Array.isArray(value) ? value.map((val) => `${key}=${val}`) : `${key}=${value}`))
                        .join("&");
                },
                responseType: "arraybuffer"
            });
            return this.handleResponse(response);
        }
        catch (error) {
            if (axios.isAxiosError(error)) {
                // Convert buffer data to string for better readability in error
                if (error.response && error.response.data) {
                    error.response.data = JSON.parse(new TextDecoder().decode(error.response.data));
                }
            }
            throw error;
        }
    }
}

const EmbeddingRequestSchema = z.object({
    input: z
        .union([z.string(), z.array(z.string())])
        .describe("Input text to embed, encoded as a string or array of strings (to embed multiple inputs in a single request). The input must not exceed the max input tokens for the model, and cannot contain empty string."),
    model: z.string().describe("The ID of the model to use. You can use the List models API to see all of your available models."),
    type: z
        .enum(["query", "document"])
        .default("document")
        .describe('Whether the input text is a "query" (used to retrieve) or a "document" (to be retrieved).'),
    encoding_format: z
        .enum(["float", "base64"])
        .default("float")
        .describe('_Optional_. The format to return the embeddings in. Can be either "float" or "base64". `base64` string should be decoded as a `float32` array. Example: `np.frombuffer(base64.b64decode(response), dtype=np.float32)`')
});
const EmbeddingResponseDataSchema = z.object({
    object: z.string().default("embedding").describe("The object type, which is always `embedding`."),
    embedding: z
        .union([z.array(z.number()), z.string()])
        .describe("The embedding vector, which is a list of floats or a base64-encoded string. The length of the vector depends on the model."),
    index: z.number().default(0).describe("The index of the embedding in the list of embeddings.")
});
const EmbeddingResponseSchema = z.object({
    object: z.string().default("list").describe("The object type, which is always `list`."),
    data: z.array(EmbeddingResponseDataSchema).describe("List of `EmbeddingResponseData`."),
    model: z.string().describe("The ID of the model used."),
    usage: ChatCompletionUsageSchema.default({
        prompt_tokens: 0,
        completion_tokens: 0,
        total_tokens: 0
    }).describe("The number of tokens consumed.")
});

z.object({
    model: z.string().optional(),
    capabilities: z
        .array(z.enum(["completion", "chat", "image", "audio", "document", "tool", "embed", "rerank"]))
        .nullable()
        .optional()
});
const ModelInfoSchema = z.object({
    id: z.string().default("openai/gpt-4o-mini"),
    object: z.string(),
    name: z.string(),
    context_length: z.number().default(16384),
    languages: z.array(z.string()),
    capabilities: z.array(z.enum(["completion", "chat", "image", "audio", "document", "tool", "embed", "rerank"])).default(["chat"]),
    owned_by: z.string()
});
const ModelInfoResponseSchema = z.object({
    object: z.enum(["chat.model_info"]),
    data: z.array(ModelInfoSchema)
});
z.object({
    prefer: z.string().optional(),
    capabilities: z
        .array(z.enum(["completion", "chat", "image", "audio", "document", "tool", "embed", "rerank"]))
        .nullable()
        .optional()
});
const ModelNamesResponseSchema = z.array(z.string());

class LLM extends Base {
    // Helper method to handle chat stream responses
    handleChatStreamResponse(response) {
        this.logWarning(response);
        if (response.status != 200) {
            throw new Error(`Received Error Status: ${response.status}`);
        }
        return new ReadableStream({
            async start(controller) {
                response.data.on("data", (data) => {
                    data = data.toString();
                    if (data.endsWith("\n\n")) {
                        const lines = data
                            .split("\n\n")
                            .filter((i) => i.trim())
                            .flatMap((line) => line.split("\n")); // Split by \n to handle collation
                        for (const line of lines) {
                            const chunk = line
                                .toString()
                                .replace(/^data: /, "")
                                .replace(/data: \[DONE\]\s+$/, "");
                            if (chunk.trim() === "[DONE]")
                                return;
                            try {
                                const parsedValue = JSON.parse(chunk);
                                if (parsedValue["object"] === "chat.completion.chunk") {
                                    controller.enqueue(StreamChatCompletionChunkSchema.parse(parsedValue));
                                }
                                else if (parsedValue["object"] === "chat.references") {
                                    controller.enqueue(ReferencesSchema.parse(parsedValue));
                                }
                                else {
                                    throw new ChunkError(`Unexpected SSE Chunk: ${parsedValue}`);
                                }
                            }
                            catch (err) {
                                if (err instanceof ChunkError) {
                                    controller.error(new ChunkError(err.message));
                                }
                                continue;
                            }
                        }
                    }
                    else {
                        const chunk = data
                            .toString()
                            .replace(/^data: /, "")
                            .replace(/data: \[DONE\]\s+$/, "");
                        if (chunk.trim() === "[DONE]")
                            return;
                        try {
                            const parsedValue = JSON.parse(chunk);
                            if (parsedValue["object"] === "chat.completion.chunk") {
                                controller.enqueue(StreamChatCompletionChunkSchema.parse(parsedValue));
                            }
                            else if (parsedValue["object"] === "chat.references") {
                                controller.enqueue(ReferencesSchema.parse(parsedValue));
                            }
                            else {
                                throw new ChunkError(`Unexpected SSE Chunk: ${parsedValue}`);
                            }
                        }
                        catch (err) {
                            if (err instanceof ChunkError) {
                                controller.error(new ChunkError(err.message));
                            }
                        }
                    }
                });
                response.data.on("error", () => {
                    controller.error("Unexpected Error");
                });
                response.data.on("end", () => {
                    if (controller.desiredSize !== null) {
                        controller.close();
                    }
                });
            }
        });
    }
    async modelInfo(params) {
        let getURL = `/api/v1/models`;
        const response = await this.httpClient.get(getURL, {
            params: params,
            paramsSerializer: {
                indexes: false
            }
        });
        return this.handleResponse(response, ModelInfoResponseSchema);
    }
    async modelNames(params) {
        let getURL = `/api/v1/model_names`;
        const response = await this.httpClient.get(getURL, {
            params: params,
            paramsSerializer: {
                indexes: false
            }
        });
        return this.handleResponse(response, ModelNamesResponseSchema);
    }
    async generateChatCompletionsStream(params) {
        const parsedParams = ChatRequestSchema.parse(params);
        parsedParams.stream = true;
        const apiURL = "/api/v1/chat/completions";
        const response = await this.httpClient.post(apiURL, parsedParams, {
            responseType: "stream"
        });
        return this.handleChatStreamResponse(response);
    }
    async generateChatCompletions(params) {
        const parsedParams = ChatRequestSchema.parse(params);
        parsedParams.stream = false;
        const apiURL = "/api/v1/chat/completions";
        const response = await this.httpClient.post(apiURL, parsedParams, {});
        return this.handleResponse(response, ChatCompletionChunkSchema);
    }
    async generateEmbeddings(params) {
        const apiURL = "/api/v1/embeddings";
        const parsedParams = EmbeddingRequestSchema.parse(params);
        const response = await this.httpClient.post(apiURL, {
            ...parsedParams
        });
        return this.handleResponse(response, EmbeddingResponseSchema);
    }
}

const TemplateTagSchema = z.object({
    id: z.string()
});
const TemplateSchema = z.object({
    id: z.string(),
    name: z.string(),
    created_at: z.string(),
    tags: z.array(TemplateTagSchema)
});
// List Templates
const ListTemplatesRequestSchema = z.object({
    search_query: z.string().default("")
});
const ListTemplatesResponseSchema = createPaginationSchema(TemplateSchema);
// Get Template
const GetTemplateRequestSchema = z.object({
    template_id: z.string()
});
const GetTemplateResponseSchema = TemplateSchema;
// List Table
const ListTablesRequestSchema = z.object({
    table_type: TableTypesSchema,
    template_id: z.string()
});
const ListTablesResponseSchema = createPaginationSchema(TableMetaResponseSchema);
// Get Table
const GetTableRequestSchema = z.object({
    template_id: z.string(),
    table_type: TableTypesSchema,
    table_id: TableIdSchema
});
const GetTableResponseSchema = TableMetaResponseSchema;
// List Table Rows
const ListTableRowsRequestSchema = z.object({
    template_id: z.string(),
    table_type: z.string(),
    table_id: TableIdSchema,
    starting_after: z.string().nullable().optional(),
    offset: z.number().int().min(0).default(0),
    limit: z.number().int().min(1).max(100).default(100),
    order_by: z.string().default("Updated at"),
    order_descending: z.boolean().default(true),
    float_decimals: z.number().int().min(0).default(0),
    vec_decimals: z.number().int().min(0).default(0)
});
const ListTableRowsResponseSchema = createPaginationSchema(z.record(z.string(), z.any()));

class Templates extends Base {
    async listTemplates(params = {}) {
        const parsedParams = ListTemplatesRequestSchema.parse(params);
        let getURL = `/api/public/v1/templates`;
        const response = await this.httpClient.get(getURL, {
            params: {
                search_query: encodeURIComponent(parsedParams.search_query)
            }
        });
        return this.handleResponse(response, ListTemplatesResponseSchema);
    }
    async getTemplate(params) {
        const parsedParams = GetTemplateRequestSchema.parse(params);
        let getURL = `/api/public/v1/templates/${parsedParams.template_id}`;
        const response = await this.httpClient.get(getURL);
        return this.handleResponse(response, GetTemplateResponseSchema);
    }
    async listTables(params) {
        const parsedParams = ListTablesRequestSchema.parse(params);
        let getURL = `/api/public/v1/templates/${parsedParams.template_id}/gen_tables/${parsedParams.table_type}`;
        const response = await this.httpClient.get(getURL);
        return this.handleResponse(response, ListTablesResponseSchema);
    }
    async getTable(params) {
        const parsedParams = GetTableRequestSchema.parse(params);
        let getURL = `/api/public/v1/templates/${parsedParams.template_id}/gen_tables/${parsedParams.table_type}/${parsedParams.table_id}`;
        const response = await this.httpClient.get(getURL);
        return this.handleResponse(response, GetTableResponseSchema);
    }
    async listTableRows(params) {
        const parsedParams = ListTableRowsRequestSchema.parse(params);
        let getURL = `/api/public/v1/templates/${parsedParams.template_id}/gen_tables/${parsedParams.table_type}/${parsedParams.table_id}/rows`;
        delete parsedParams.template_id;
        delete parsedParams.table_type;
        delete parsedParams.table_id;
        const response = await this.httpClient.get(getURL, {
            params: parsedParams
        });
        return this.handleResponse(response, ListTableRowsResponseSchema);
    }
}

class JamAI extends Base {
    table;
    llm;
    template;
    file;
    /**
     * Creates an instance of APIClient.
     * @param {string} baseURL Base URL for the API requests. Default url is - https://api.jamaibase.com
     * @param {string} token PAT.
     * @param {string} projectId Project ID.
     * @param {number=} [maxRetries=0] Maximum number of retries for failed requests. Defaults value is 0.
     * @param {AxiosInstance} [httpClient] Axios instance for making HTTP requests. If not provided, a default instance will be created.
     * @param {number} [timeout] Timeout (ms) for the requests. Default value is none.
     */
    constructor(config) {
        super(config);
        this.table = new GenTable(config);
        this.llm = new LLM(config);
        this.template = new Templates(config);
        this.file = new Files(config);
    }
    setApiKey(token) {
        super.setApiKey(token);
    }
    setProjId(projectId) {
        super.setProjId(projectId);
    }
    /**
     * Options for configuring the HTTP agent.
     * @property {Boolean} [keepAlive=true] - Keep sockets around in a pool to be used by other requests in the future. Default is true.
     * @property {Number} [keepAliveMsecs=1000] - Initial delay for TCP Keep-Alive packets when keepAlive is enabled. Defaults to 1000 milliseconds. Only relevant if keepAlive is true.
     * @property {Number} [freeSocketTimeout=20000] - Timeout for free sockets after inactivity, in milliseconds. Default is 20000 milliseconds. Only relevant if keepAlive is true.
     * @property {Number} [timeout] - Timeout for working sockets after inactivity, in milliseconds. Default is calculated as freeSocketTimeout * 2 if greater than or equal to 8000 milliseconds, otherwise the default is 8000 milliseconds.
     * @property {Number} [maxSockets=Infinity] - Maximum number of sockets to allow per host. Default is Infinity.
     * @property {Number} [maxFreeSockets=10] - Maximum number of free sockets per host to keep open. Only relevant if keepAlive is true. Default is 10.
     * @property {Number} [socketActiveTTL=null] - Sets the time to live for active sockets, even if in use. If not set, sockets are released only when free. Default is null.
     */
    setHttpagentConfig(payload) {
        super.setHttpagentConfig(payload);
    }
    /**
     * Options for configuring the HTTP agent.
     * @property {Boolean} [keepAlive=true] - Keep sockets around in a pool to be used by other requests in the future. Default is true.
     * @property {Number} [keepAliveMsecs=1000] - Initial delay for TCP Keep-Alive packets when keepAlive is enabled. Defaults to 1000 milliseconds. Only relevant if keepAlive is true.
     * @property {Number} [freeSocketTimeout=20000] - Timeout for free sockets after inactivity, in milliseconds. Default is 20000 milliseconds. Only relevant if keepAlive is true.
     * @property {Number} [timeout] - Timeout for working sockets after inactivity, in milliseconds. Default is calculated as freeSocketTimeout * 2 if greater than or equal to 8000 milliseconds, otherwise the default is 8000 milliseconds.
     * @property {Number} [maxSockets=Infinity] - Maximum number of sockets to allow per host. Default is Infinity.
     * @property {Number} [maxFreeSockets=10] - Maximum number of free sockets per host to keep open. Only relevant if keepAlive is true. Default is 10.
     * @property {Number} [socketActiveTTL=null] - Sets the time to live for active sockets, even if in use. If not set, sockets are released only when free. Default is null.
     */
    setHttpsagentConfig(payload) {
        super.setHttpsagentConfig(payload);
    }
    setAuthHeader(header) {
        super.setAuthHeader(header);
    }
    async health() {
        return await super.health();
    }
}

export { JamAI as default };
//# sourceMappingURL=index.mjs.map
